/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/example/hello": {
    /**
     * Say hello 
     * @description Say hello to the world
     */
    get: operations["query.example.hello"];
  };
  "/example/create": {
    /**
     * Create example 
     * @description Create an example object in the database
     */
    post: operations["mutation.example.create"];
  };
  "/example/getAll": {
    /**
     * Get all examples 
     * @description Get all examples
     */
    get: operations["query.example.getAll"];
  };
  "/example/getSecretMessage": {
    /**
     * Get secret message 
     * @description This endpoint will return a message that tells you what type of authentication you used, if you are authenticated.
     */
    get: operations["query.example.getSecretMessage"];
  };
  "/games": {
    /**
     * Get All Games 
     * @description Get all Games. Paginated by default. Supports filtering and sorting.
     */
    get: operations["query.games.getAll"];
    /**
     * Delete Games 
     * @description Delete one or more Games by their IDs
     */
    delete: operations["mutation.games.delete"];
  };
  "/games/count": {
    /**
     * Get Game Count 
     * @description Get Game Count
     */
    get: operations["query.games.getCount"];
  };
  "/games/getPlayerScores": {
    /**
     * Get Player Scores 
     * @description Get a player's score data for a specific game
     */
    get: operations["query.games.getPlayerScores"];
  };
  "/game-objects": {
    /**
     * Get All Game Objects 
     * @description Get all Game Objects. Paginated by default. Supports filtering and sorting.
     */
    get: operations["query.gameObjects.getAll"];
    /**
     * Delete Game Objects 
     * @description Delete one or more game objects by their IDs
     */
    delete: operations["mutation.gameObjects.delete"];
  };
  "/game-objects/count": {
    /**
     * Get Game Object Count 
     * @description Get the total Game Object count. Supports filtering.
     */
    get: operations["query.gameObjects.getCount"];
  };
  "/game-objects/ranked": {
    /**
     * Get Ranked Results 
     * @description Get ranked Game Object results for a player
     */
    get: operations["query.gameObjects.getRanked"];
  };
  "/tags": {
    /**
     * Get All Tags 
     * @description Get all tags
     */
    get: operations["query.tags.getAll"];
    /**
     * Create Tag 
     * @description Create Tag
     */
    post: operations["mutation.tags.create"];
    /**
     * Delete Tags 
     * @description Delete one or more Tags by their IDs
     */
    delete: operations["mutation.tags.delete"];
  };
  "/tags/count": {
    /**
     * Get Tag Count 
     * @description Get Tag Count
     */
    get: operations["query.tags.getCount"];
  };
  "/players/create": {
    /**
     * Create Player 
     * @description Creates a player with the given ID and an optional name. The ID must be unique, and ideally corresponds with a user ID used by the app integrating with 2bttns.
     */
    post: operations["mutation.players.create"];
  };
  "/players": {
    /**
     * Get All Players 
     * @description Get all players
     */
    get: operations["query.players.getAll"];
  };
  "/players/count": {
    /**
     * Get Player Count 
     * @description Get player count
     */
    get: operations["query.players.getCount"];
  };
  "/players/{id}": {
    /**
     * Get Player by ID 
     * @description Get player by ID
     */
    get: operations["query.players.getById"];
    /**
     * Update Player by ID 
     * @description Update player by ID.
     */
    put: operations["mutation.players.updateById"];
    /**
     * Delete Player by ID 
     * @description Delete player by ID
     */
    delete: operations["mutation.players.deleteById"];
  };
  "/export-data": {
    /**
     * Export Data 
     * @description Get exported 2bttns data. 
     * 
     * You can choose to export all data or only the data you need from the Game, Tag, and Game Object database tables used by 2bttns. 
     * 
     * Supports JSON format.
     */
    get: operations["query.exportData.exportData"];
  };
  "/import-data": {
    /**
     * Import Data 
     * @description Import 2bttns data from a JSON file.
     */
    post: operations["mutation.importData.importData"];
  };
  "/administrators": {
    /**
     * Get All Admins 
     * @description Get all administrators
     */
    get: operations["query.administrators.getAll"];
  };
  "/administrators/count": {
    /**
     * Get Admin Count 
     * @description Get the total number of administrators. Useful for pagination.
     */
    get: operations["query.administrators.getCount"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: never;
  responses: {
    /** @description Error response */
    error: {
      content: {
        "application/json": {
          message: string;
          code: string;
          issues?: ({
              message: string;
            })[];
        };
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  "query.example.hello": {
    /**
     * Say hello 
     * @description Say hello to the world
     */
    parameters?: {
      query?: {
        text?: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            greeting: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.example.create": {
    /**
     * Create example 
     * @description Create an example object in the database
     */
    requestBody?: {
      content: {
        "application/json": {
          id?: string;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            id: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.example.getAll": {
    /**
     * Get all examples 
     * @description Get all examples
     */
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            examples: ({
                id: string;
                /** Format: date-time */
                createdAt: string;
                /** Format: date-time */
                updatedAt: string;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.example.getSecretMessage": {
    /**
     * Get secret message 
     * @description This endpoint will return a message that tells you what type of authentication you used, if you are authenticated.
     */
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": string;
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.games.getAll": {
    /**
     * Get All Games 
     * @description Get all Games. Paginated by default. Supports filtering and sorting.
     */
    parameters?: {
        /** @description Comma-separated Game IDs to filter by */
        /** @description Set to `true` to enable fuzzy ID filtering. If false, only returns exact matches. */
        /** @description Comma-separated Game names to filter by */
        /** @description Set to `true` to enable fuzzy name filtering. If false, only returns exact matches. */
        /** @description Comma-separated list of input tag IDs the resulting game must have */
        /** @description Comma-separated list of input tag IDs to exclude from the response. Use this to exclude games that have a specific input tag, even if they match the `requiredTags` filter. */
        /**
         * @description `include`: Include all games, regardless of whether they have input tags or not. 
         * 
         * `exclude`: Exclude games that have no input tags. 
         * 
         * `untagged-only`: Only return games that have no input tags. Setting this option will ignore `requiredTags` and `excludeTags`, since tagged items shouldn't appear in the results.
         */
        /** @description Field to sort by */
        /** @description Sort order for the selected field */
        /** @description Set to `true` to include additional tags info in the response */
        /** @description Comma-separated list of Game IDs to exclude from the response */
      query?: {
        take?: Record<string, never> | number;
        skip?: Record<string, never> | number;
        idFilter?: Record<string, never> | (string)[];
        allowFuzzyIdFilter?: boolean;
        nameFilter?: Record<string, never> | (string)[];
        allowFuzzyNameFilter?: boolean;
        tagFilter?: Record<string, never> | (string)[];
        tagExcludeFilter?: Record<string, never> | (string)[];
        untaggedFilter?: "include" | "exclude" | "untagged-only";
        sortField?: "id" | "name" | "description" | "updatedAt" | "createdAt" | "inputTags" | "mode";
        sortOrder?: "asc" | "desc";
        includeTagData?: boolean;
        excludeGames?: Record<string, never> | (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            games: ({
                id: string;
                name: string;
                description: string | null;
                /** @description ISO date string */
                createdAt: string;
                /** @description ISO date string */
                updatedAt: string;
                /** @description Input Tag IDs */
                inputTags: (string)[];
                mode: string;
              })[];
            tags?: ({
                id: string;
                name: string;
                description: string | null;
                /** @description ISO date string */
                createdAt: string;
                /** @description ISO date string */
                updatedAt: string;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.games.delete": {
    /**
     * Delete Games 
     * @description Delete one or more Games by their IDs
     */
    parameters?: {
      query?: {
        id?: (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            deletedCount: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.games.getCount": {
    /**
     * Get Game Count 
     * @description Get Game Count
     */
    parameters?: {
        /** @description Comma-separated Game IDs to filter by */
        /** @description Set to `true` to enable fuzzy ID filtering. If false, only returns exact matches. */
        /** @description Comma-separated Game names to filter by */
        /** @description Set to `true` to enable fuzzy name filtering. If false, only returns exact matches. */
        /** @description Comma-separated list of input tag IDs the resulting game must have */
        /** @description Comma-separated list of input tag IDs to exclude from the response. Use this to exclude games that have a specific input tag, even if they match the `requiredTags` filter. */
        /**
         * @description `include`: Include all games, regardless of whether they have input tags or not. 
         * 
         * `exclude`: Exclude games that have no input tags. 
         * 
         * `untagged-only`: Only return games that have no input tags. Setting this option will ignore `requiredTags` and `excludeTags`, since tagged items shouldn't appear in the results.
         */
        /** @description Comma-separated list of Game IDs to exclude from the response */
      query?: {
        idFilter?: Record<string, never> | (string)[];
        allowFuzzyIdFilter?: boolean;
        nameFilter?: Record<string, never> | (string)[];
        allowFuzzyNameFilter?: boolean;
        tagFilter?: Record<string, never> | (string)[];
        tagExcludeFilter?: Record<string, never> | (string)[];
        untaggedFilter?: "include" | "exclude" | "untagged-only";
        excludeGames?: Record<string, never> | (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            count: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.games.getPlayerScores": {
    /**
     * Get Player Scores 
     * @description Get a player's score data for a specific game
     */
    parameters: {
        /** @description The game id to get scores for */
        /** @description The player id to get scores for */
        /** @description Whether to include game objects in the response */
      query: {
        game_id: string;
        player_id: string;
        include_game_objects?: boolean;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            playerScores: ({
                createdAt: string;
                updatedAt: string;
                score: number;
                playerId: string;
                gameObjectId: string;
                gameObject?: {
                  id: string;
                  createdAt: string;
                  updatedAt: string;
                  name: string;
                  description: string | null;
                };
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.gameObjects.getAll": {
    /**
     * Get All Game Objects 
     * @description Get all Game Objects. Paginated by default. Supports filtering and sorting.
     */
    parameters?: {
        /** @description Comma-separated Game Object IDs to filter by */
        /** @description Set to `true` to enable fuzzy ID filtering. If false, only returns exact matches. */
        /** @description Comma-separated Game Object names to filter by */
        /** @description Set to `true` to enable fuzzy name filtering. If false, only returns exact matches. */
        /** @description Comma-separated list of tag IDs the resulting game objects must have */
        /** @description Comma-separated list of tag IDs to exclude from the response. Use this to exclude game objects that have a specific tag, even if they match the `requiredTags` filter. */
        /**
         * @description `include`: Include all game objects, regardless of whether they have tags or not. 
         * 
         * `exclude`: Exclude game objects that have no tags. 
         * 
         * `untagged-only`: Only return game objects that have no tags. Setting this option will ignore `requiredTags` and `excludeTags`, since tagged items shouldn't appear in the results.
         */
        /** @description Field to sort by */
        /** @description Sort order for the selected field */
        /** @description Set to `true` to include additional tags info in the response */
        /** @description Comma-separated list of Game Object IDs to exclude from the response */
      query?: {
        take?: Record<string, never> | number;
        skip?: Record<string, never> | number;
        idFilter?: Record<string, never> | (string)[];
        allowFuzzyIdFilter?: boolean;
        nameFilter?: Record<string, never> | (string)[];
        allowFuzzyNameFilter?: boolean;
        tagFilter?: Record<string, never> | (string)[];
        tagExcludeFilter?: Record<string, never> | (string)[];
        untaggedFilter?: "include" | "exclude" | "untagged-only";
        sortField?: "id" | "name" | "description" | "updatedAt" | "createdAt" | "tags" | "related";
        sortOrder?: "asc" | "desc";
        includeTagData?: boolean;
        excludeGameObjects?: Record<string, never> | (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            gameObjects: ({
                id: string;
                name: string;
                description: string | null;
                /** @description ISO date string */
                createdAt: string;
                /** @description ISO date string */
                updatedAt: string;
                /** @description Tag IDs */
                tags: (string)[];
                related: (string)[];
              })[];
            tags?: ({
                id: string;
                name: string;
                description: string | null;
                /** @description ISO date string */
                createdAt: string;
                /** @description ISO date string */
                updatedAt: string;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.gameObjects.delete": {
    /**
     * Delete Game Objects 
     * @description Delete one or more game objects by their IDs
     */
    parameters?: {
      query?: {
        id?: (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            deletedCount: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.gameObjects.getCount": {
    /**
     * Get Game Object Count 
     * @description Get the total Game Object count. Supports filtering.
     */
    parameters?: {
        /** @description Comma-separated Game Object IDs to filter by */
        /** @description Set to `true` to enable fuzzy ID filtering. If false, only returns exact matches. */
        /** @description Comma-separated Game Object names to filter by */
        /** @description Set to `true` to disable fuzzy name filtering. If false, only returns exact matches. */
        /** @description Comma-separated list of tag IDs the resulting game objects must have */
        /** @description Comma-separated list of tag IDs to exclude from the response. Use this to exclude game objects that have a specific tag, even if they match the `requiredTags` filter. */
        /**
         * @description `include`: Include all game objects, regardless of whether they have tags or not. 
         * 
         * `exclude`: Exclude game objects that have no tags. 
         * 
         * `untagged-only`: Only return game objects that have no tags. Setting this option will ignore `requiredTags` and `excludeTags`, since tagged items shouldn't appear in the results.
         */
        /** @description Comma-separated list of Game Object IDs to exclude from the response */
      query?: {
        idFilter?: Record<string, never> | (string)[];
        allowFuzzyIdFilter?: boolean;
        nameFilter?: Record<string, never> | (string)[];
        allowFuzzyNameFilter?: boolean;
        tagFilter?: Record<string, never> | (string)[];
        tagExcludeFilter?: Record<string, never> | (string)[];
        untaggedFilter?: "include" | "exclude" | "untagged-only";
        excludeGameObjects?: Record<string, never> | (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            count: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.gameObjects.getRanked": {
    /**
     * Get Ranked Results 
     * @description Get ranked Game Object results for a player
     */
    parameters: {
        /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
        /**
         * @description Specify comma-separated input tags that will be used to score the game objects associated with the output tag.
         * 
         * If the output tag is included in the input tags, the player's score for those game object will be used as base scores
         */
        /** @description Specify the output tag of the game objects to get ranked results for */
      query: {
        playerId: string;
        inputTags: string;
        outputTag: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            scores: ({
                gameObject: {
                  id: string;
                  name: string;
                };
                score: number;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.tags.getAll": {
    /**
     * Get All Tags 
     * @description Get all tags
     */
    parameters?: {
        /** @description Comma-separated tag IDs to filter by */
        /** @description Comma-separated tag names to filter by */
        /** @description Field to sort by */
        /** @description Sort order for the selected field */
      query?: {
        idFilter?: Record<string, never> | (string)[];
        nameFilter?: Record<string, never> | (string)[];
        take?: Record<string, never> | number;
        skip?: Record<string, never> | number;
        sortField?: "id" | "name" | "description" | "updatedAt" | "createdAt";
        sortOrder?: "asc" | "desc";
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            tags: ({
                id: string;
                name: string;
                description: string | null;
                /** @description ISO date string */
                createdAt: string;
                /** @description ISO date string */
                updatedAt: string;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.tags.create": {
    /**
     * Create Tag 
     * @description Create Tag
     */
    requestBody: {
      content: {
        "application/json": {
          /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
          id?: string;
          name: string;
          description?: string;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            createdTag: {
              id: string;
              name: string;
              description: string | null;
              /** @description ISO date string */
              createdAt: string;
              /** @description ISO date string */
              updatedAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.tags.delete": {
    /**
     * Delete Tags 
     * @description Delete one or more Tags by their IDs
     */
    parameters?: {
      query?: {
        id?: (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            deletedCount: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.tags.getCount": {
    /**
     * Get Tag Count 
     * @description Get Tag Count
     */
    parameters?: {
        /** @description Comma-separated tag IDs to filter by */
        /** @description Comma-separated tag names to filter by */
      query?: {
        idFilter?: Record<string, never> | (string)[];
        nameFilter?: Record<string, never> | (string)[];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            count: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.players.create": {
    /**
     * Create Player 
     * @description Creates a player with the given ID and an optional name. The ID must be unique, and ideally corresponds with a user ID used by the app integrating with 2bttns.
     */
    requestBody: {
      content: {
        "application/json": {
          /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
          id: string;
          name?: string;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            createdPlayer: {
              /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
              id: string;
              name?: string | null;
              /** @description ISO date string */
              createdAt: string;
              /** @description ISO date string */
              updatedAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.players.getAll": {
    /**
     * Get All Players 
     * @description Get all players
     */
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            players: ({
                id: string;
                name?: string | null;
                /** @description ISO date string */
                createdAt: string;
                /** @description ISO date string */
                updatedAt: string;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.players.getCount": {
    /**
     * Get Player Count 
     * @description Get player count
     */
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            count: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.players.getById": {
    /**
     * Get Player by ID 
     * @description Get player by ID
     */
    parameters: {
        /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            player: {
              id: string;
              name?: string | null;
              /** @description ISO date string */
              createdAt: string;
              /** @description ISO date string */
              updatedAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.players.updateById": {
    /**
     * Update Player by ID 
     * @description Update player by ID.
     */
    parameters: {
        /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          data?: {
            /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
            id?: string;
            name?: string;
          };
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            updatedPlayer: {
              id: string;
              name?: string | null;
              /** @description ISO date string */
              createdAt: string;
              /** @description ISO date string */
              updatedAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.players.deleteById": {
    /**
     * Delete Player by ID 
     * @description Delete player by ID
     */
    parameters: {
        /** @description ID value. Only alphanumeric, underscore, and hyphen are allowed. */
      path: {
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            deletedPlayer: {
              id: string;
              name?: string | null;
              /** @description ISO date string */
              createdAt: string;
              /** @description ISO date string */
              updatedAt: string;
            };
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.exportData.exportData": {
    /**
     * Export Data 
     * @description Get exported 2bttns data. 
     * 
     * You can choose to export all data or only the data you need from the Game, Tag, and Game Object database tables used by 2bttns. 
     * 
     * Supports JSON format.
     */
    parameters?: {
        /**
         * @description Set to true to export Games. 
         * 
         * The Game data will include associated Tag IDs if `includeTags` is `true`
         */
        /**
         * @description Set to true to export Game Objects. 
         * 
         * The GameObject data will include associated Tag IDs if `includeTags` is `true`
         */
        /** @description Set to true to export Tags. */
        /**
         * @description `include`: include the count of each type of data exported with the results
         * 
         * `count-only`: only return the count of each type of data that would be exported. Useful if you only want the count and not the actual data.
         * 
         * `no-count`: do not include the count
         */
        /**
         * @description Comma-separated ID list of Games to export.
         * 
         * Leave this field empty if you want the results to include all Games.
         */
        /**
         * @description Comma-separated ID list of GameObjects to export.
         * 
         * Leave this field empty if you want the results to include all GameObjects.
         */
        /** @description Set to `false` to exclude GameObjects that have no tags. */
        /**
         * @description Comma-separated ID list of Tags to export.
         * 
         * Leave this field empty if you want the results to include all Tags.
         */
        /** @description Set to `true` to only include Tags that are associated with the games that are being exported. */
        /** @description Set to `true` to only include Tags that are associated with the game objects that are being exported. */
      query?: {
        includeGames?: boolean;
        includeGameObjects?: boolean;
        includeTags?: boolean;
        count?: "include" | "count-only" | "no-count";
        filterGameIds?: Record<string, never> | (string)[];
        filterGameObjectIds?: Record<string, never> | (string)[];
        filterAllowUntaggedGameObjects?: boolean;
        filterTagIds?: Record<string, never> | (string)[];
        filterTagsMustBeInGames?: boolean;
        filterTagsMustBeInGameObjects?: boolean;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            count?: {
              games?: number;
              gameObjects?: number;
              tags?: number;
            };
            games?: ({
                id: string;
                name: string;
                description: string;
                inputTagIds?: (string)[];
              })[];
            gameObjects?: ({
                id: string;
                name: string;
                description: string;
                tagIds?: (string)[];
              })[];
            tags?: ({
                id: string;
                name: string;
                description: string;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "mutation.importData.importData": {
    /**
     * Import Data 
     * @description Import 2bttns data from a JSON file.
     */
    requestBody: {
      content: {
        "application/json": {
          /** @description Base64 encoded JSON file to import */
          jsonBase64: string;
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            message: string;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.administrators.getAll": {
    /**
     * Get All Admins 
     * @description Get all administrators
     */
    parameters?: {
        /** @description Comma-separated emails to filter by */
        /** @description Set to `true` to enable fuzzy email filtering. If false, only returns exact matches. */
        /** @description Field to sort by */
        /** @description Sort order for the selected field */
      query?: {
        take?: Record<string, never> | number;
        skip?: Record<string, never> | number;
        emailFilter?: Record<string, never> | (string)[];
        allowFuzzyEmailFilter?: boolean;
        sortField?: "email" | "updatedAt" | "createdAt";
        sortOrder?: "asc" | "desc";
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            administrators: ({
                email: string;
                /** @description ISO date string */
                createdAt: string;
                /** @description ISO date string */
                updatedAt: string;
              })[];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "query.administrators.getCount": {
    /**
     * Get Admin Count 
     * @description Get the total number of administrators. Useful for pagination.
     */
    parameters?: {
        /** @description Comma-separated emails to filter by */
        /** @description Set to `true` to enable fuzzy email filtering. If false, only returns exact matches. */
      query?: {
        emailFilter?: Record<string, never> | (string)[];
        allowFuzzyEmailFilter?: boolean;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            count: number;
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
}
